--[[
  PARalel eXecution Engine (PARXE) for APRIL-ANN
  Copyright (C) 2015  Francisco Zamora-Martinez

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]
local common   = require "parxe.common"
local config   = require "parxe.config"
local future   = require "parxe.future"
local xe       = require "xemsg"
local xe_utils = require "parxe.xemsg_utils"

local serialize   = xe_utils.serialize
local deserialize = xe_utils.deserialize

---------------------------------------------------------------------------
-- TMPNAME allows to identify this server, allowing to execute several servers
-- in the same host. The hash part is the particular random sequence of
-- characters generated by Lua to distinguish the tmpname file. This hash part
-- is used to  identify client connections in order to assert possible errors.
local TMPNAME  = os.tmpname()
local HASH     = TMPNAME:match("^.*lua_(.*)$")
local HOSTNAME = common.hostname()
---------------------------------------------------------------------------

-- Used at clear_tmp() function.
local pending_tmp_files = {}

-- Used in xe.poll() function.
local poll_fds = {}

-- A table with all the futures related with executed processes. The table is
-- indexed as a dictionary using task_ids as keys.
local pending_futures = {}
local pending_tasks = {}

-- clears the files created at tmp folder
function clean_tmp()
  local wait_exists = common.wait_exists
  local remove = os.remove
  for _,filename in ipairs(pending_tmp_files) do
    wait_exists(filename)
    remove(filename)
  end
end

----------------------------- check worker helpers ---------------------------

-- given a future object, serializes its associated task by means of server
-- SP socket
local function send_task(f, host)
  serialize(f.task, f.server)
  f._state_ = future.RUNNING_STATE
end

-- given a worker reply, returns a true to the worker and process the result
-- modifying its corresponding future object
local function process_reply(r)
  local f = pending_futures[r.id]
  assert(f.task_id == r.id, "Unexpected error")
  local server = f.server
  serialize(true, server)
  pending_futures[r.id] = nil
  local task = f.task
  f.task     = nil
  f.server   = nil
  f.tmpname  = nil
  f.task_id  = nil
  f.time     = nil
  f._result_ = r.result or {false}
  f._err_    = r.err
  return task
end

-- reads a message request from socket s and executes the corresponding response
local function process_message(s, revents)
  assert(revents == xe.NN_POLLIN)
  local engine = config.engine()
  if revents == xe.NN_POLLIN then
    local cmd = deserialize(s)
    engine:check_asserts(cmd)
    if cmd.request then
      -- task request, send a reply with the task
      send_task(pending_futures[cmd.id], cmd.host)
    elseif cmd.reply then
      -- task reply, read task result and send ack
      local task = process_reply(cmd)
      engine:finished(task)
      if cmd.err then fprintf(io.stderr, "ERROR IN TASK %d: %s\n", cmd.id, cmd.err) end
      return true
    else
      error("Incorrect command")
    end
  end
end

------------------------ check worker function -------------------------------

-- This function is the main one for future objects produced by the engine.
-- This function is responsible of look-up for new incoming messages and
-- dispatch its response by using process_message function.
local function check_worker()
  local engine = config.engine()
  while #pending_tasks > 0 and engine:acceptting_tasks() do
    local task = table.remove(pending_tasks, 1)
    local f = pending_futures[task.id]
    engine:execute(task, f._stdout_, f._stderr_)
  end
  repeat
    local n = assert( xe.poll(poll_fds) )
    if n > 0 then
      for i,r in ipairs(poll_fds) do
        if r.events == r.revents then
          process_message(r.fd, r.revents)
          r.revents = nil
        end
      end
    end
  until n == 0
  collectgarbage("collect")
end

---------------------------------------------------------------------------

local sched,sched_methods = class("parxe.scheduler")

local function init(self)
  local engine = config.engine()
  local server = engine:init()
  if #poll_fds == 0 then
    poll_fds[1] = { fd = server, events = xe.NN_POLLIN }
  end
  return engine,server
end

function sched:destructor()
  if config.clean_tmp_at_exit() then clean_tmp() end
end

function sched_methods:enqueue(func, ...)
  local engine,server = init(self)
  local args    = table.pack(...)
  local task_id = common.next_task_id()
  local tmp     = config.tmp()
  local tmpname = "%s/PX_%s_%06d_%s"%{tmp,HASH,task_id,os.date("%Y%m%d%H%M%S")}
  local task    = { id=task_id, func=func, args=args, wd=config.wd(), hash=HASH }
  local f = future(check_worker)
  f._stdout_  = tmpname..".OU"
  f._stderr_  = tmpname..".ER"
  f.tmpname   = tmpname
  f.task      = task
  f.task_id   = task_id
  f.time      = common.gettime()
  f.server    = server
  pending_futures[task_id] = f
  table.insert(pending_tmp_files, f._stdout_)
  table.insert(pending_tmp_files, f._stderr_)
  if engine:acceptting_tasks() then
    engine:execute(task, f._stdout_, f._stderr_)
  else
    table.insert(pending_tasks, task)
  end
  return f
end

-- waits until all futures are ready
function sched_methods:wait()
  repeat
    for id,f in pairs(pending_futures) do
      f:wait()
      pending_futures[id] = nil
    end
  until not next(pending_futures)
end

----------------------------------------------------------------------------

local singleton = sched()
class.extend_metamethod(sched, "__call", function() return singleton end)
return singleton
