--[[
  PARalel eXecution Engine (PARXE) for APRIL-ANN
  Copyright (C) 2015  Francisco Zamora-Martinez

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
--]]
local common   = require "parxe.common"
local config   = require "parxe.config"
local xe       = require "xemsg"

-- number of cores available in local machine
local num_cores = tonumber( assert( io.popen("getconf _NPROCESSORS_ONLN") ):read("*l") )

local local_class,local_methods = class("parxe.engine.local")

function local_class:constructor()
  ---------------------------------------------------------------------------
  -- TMPNAME allows to identify this server, allowing to execute several servers
  -- in the same host. The hash part is the particular random sequence of
  -- characters generated by Lua to distinguish the tmpname file. This hash part
  -- is used to  identify client connections in order to assert possible errors.
  self.TMPNAME  = os.tmpname()
  self.HASH     = self.TMPNAME:match("^.*lua_(.*)$")
  local f = io.open(self.TMPNAME,"w")
  f:write("PARXE local engine\n")
  f:close()
  
  -- nanomsg URI connection, using IPC transport
  self.URI = "ipc://"..self.TMPNAME
  
  -- A dictionary with PID keys of all workers currently executing work
  self.running_workers = {}
  self.num_running_workers = 0 -- it should be less or equal to num_cores

  -- Forward declaration of server socket and binded endpoint identifier, for
  -- attention of the reader.
  self.server = nil
  self.endpoint = nil
  self.server_url = nil
  self.client_url = nil
end

function local_class:destructor()
  if self.server then
    self.server:shutdown(self.endpoint)
    self.server:close()
  end
  if self.TMPNAME then os.remove(self.TMPNAME) end
end

function local_methods:destroy()
  local_class.destructor(self)
  for k,v in pairs(self) do self[k] = nil end
end

function local_methods:init()
  if not self.server then
    self.server = assert( xe.socket(xe.NN_REP) )
    self.endpoint = assert( self.server:bind(self.URI) )
  end
  return self.server
end

function local_methods:abort(task)
  error("Not implemented")
end

function local_methods:check_asserts(cmd)
  assert(cmd.hash == self.HASH,
         "Warning: unknown hash identifier, check that every server has a different port\n")
end

function local_methods:acceptting_tasks()
  return self.num_running_workers < num_cores
end

-- Executes local passing it the worker script and resources
-- configuration.
function local_methods:execute(task, stdout, stderr)
  -- local which,pid = util.split_process(2)
  -- if not pid then
  local file = (arg or {[-1]="april-ann"})[-1]
  local cmd = "nohup %s -l %s -e \"RUN_WORKER('%s','%s',%d)\" > %s 2> %s & echo $!"%
    { file, "parxe.worker", self.URI, self.HASH, task.id,
      stdout, stderr }
  local pipe = io.popen(cmd)
  local pid = tonumber(pipe:read("*l"))
  pipe:close()
  --end
  assert(pid >= 0, "Unexpected PID < 0")
  -- parent code, keep track of pid and task_id for error checking
  self.running_workers[pid] = task.id
  self.num_running_workers  = self.num_running_workers + 1
  task.pid = pid
end

function local_methods:finished(task)
  self.running_workers[task.pid] = nil
  self.num_running_workers = self.num_running_workers - 1
end

function local_methods:get_max_tasks() return num_cores end

----------------------------------------------------------------------------

return local_class
