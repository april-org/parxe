--[[
  PARalel eXecution Engine (PARXE) for APRIL-ANN
  Copyright (C) 2015  Francisco Zamora-Martinez

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]
local common   = require "parxe.common"
local config   = require "parxe.config"
local xe       = require "xemsg"

local HOSTNAME = common.hostname()
-- Table with all allowed resources for SSH configuration. They can be setup
-- by means of set_resource method in ssh engine object.
local allowed_resources = { omp=true, appname=true, host=true, port=true }
-- List of available machines. If one machine has multiple cores, you should put
-- it several times in this list. By default the list is empty.
local machines = {}
-- Value of resources for SSH configuration.
local resources = { omp=1, appname="april-ann", host=HOSTNAME, port=2345 }
-- Lines of shell script to be executed by SSH script before running worker
local shell_lines = {}
-- List of idle machines.
local idle_machines = {}
local num_remote_cores = 0

local ssh,ssh_methods = class("parxe.engine.ssh")

function ssh:constructor()
  ---------------------------------------------------------------------------
  -- TMPNAME allows to identify this server, allowing to execute several servers
  -- in the same host. The hash part is the particular random sequence of
  -- characters generated by Lua to distinguish the tmpname file. This hash part
  -- is used to  identify client connections in order to assert possible errors.
  self.TMPNAME  = os.tmpname()
  self.HASH     = self.TMPNAME:match("^.*lua_(.*)$")
  local f = io.open(self.TMPNAME,"w")
  f:write("PARXE ssh engine\n")
  f:close()
  ---------------------------------------------------------------------------

  ---------------------------------------------------------------------------

  -- Forward declaration of server socket and binded endpoint identifier, for
  -- attention of the reader.
  self.server = nil
  self.endpoint = nil
  self.server_url = nil
  self.client_url = nil

  common.user_conf("ssh.lua", self)
end

function ssh:destructor()
  if self.server then
    self.server:shutdown(self.endpoint)
    self.server:close()
  end
  if self.TMPNAME then os.remove(self.TMPNAME) end
end

function ssh_methods:destroy()
  ssh.destructor(self)
  for k,v in pairs(self) do self[k] = nil end
end

function ssh_methods:init()
  if not self.server then
    self.server_url = "tcp://*:%d"%{resources.port}
    self.client_url = "tcp://%s:%d"%{resources.host,resources.port}
    self.server = assert( xe.socket(xe.NN_REP) )
    self.endpoint = assert( self.server:bind(self.server_url) )
  end
  return self.server
end

function ssh_methods:abort(task)
  error("Not implemented")
end

function ssh_methods:check_asserts(cmd)
  assert(cmd.hash == self.HASH,
         "Warning: unknown hash identifier, check that every server has a different port\n")
end

function ssh_methods:acceptting_tasks()
  assert(num_remote_cores>0, "SHH engine requires at least one core")
  return #idle_machines > 0
end

-- Executes ssh passing it the worker script and resources
-- configuration.
function ssh_methods:execute(task, stdout, stderr)
  local machine_key = assert( table.remove(idle_machines, 1) )
  local tmp = config.tmp()
  local tmpname = "%s/PX_%s_%06d_%s"%{tmp,self.HASH,task.id,os.date("%Y%m%d%H%M%S")}
  task.machine = machine_key
  local command = {
    "source ~/.bashrc",
    "cd "..task.wd,
    "export OMP_NUM_THREADS="..resources.omp,
  }
  for _,v in pairs(shell_lines) do table.insert(command, v) end
  table.insert(command,
               "if [[ -z %s ]]; then echo Impossible to expand appname; exit -1; fi"%{resources.appname})
  table.insert(command,
               'nohup %s -l parxe.worker -e "RUN_WORKER([[%s]],[[%s]],%d)" > %s 2> %s < /dev/null &'%
                 { resources.appname, self.client_url, self.HASH, task.id, stdout, stderr, })
  local s = table.concat{ "ssh ", machines[machine_key],
                          " '",
                          table.concat(command, ";"),
                          "'" }
  assert( os.execute(s) )
  -- return pid ????? Is it possible to control the SSH command?
end

function ssh_methods:finished(task)
  table.insert(idle_machines, task.machine)
  task.machine = nil
end

function ssh_methods:get_max_tasks() return num_remote_cores end

-- configure SSH resources
function ssh_methods:set_resource(key, value)
  april_assert(allowed_resources[key], "Not allowed resources name %s", key)
  resources[key] = value
  if key == "port" and self.server then
    fprintf(io.stderr, "Unable to change port after any task has been executed")
  end
end

-- appends a new shell line which will be executed before running the worker
function ssh_methods:append_shell_line(value)
  table.insert(shell_lines, value)
end

-- adds a new machine given the login@host credential and the number of cores
function ssh_methods:add_machine(login_host, num_cores)
  -- check ssh connectivity
  local f = assert( io.popen("ssh -n %s 'getconf _NPROCESSORS_ONLN'"%{login_host}),
                    "Unable to connect" )
  local n = assert( tonumber( f:read("*l") ),
                    "Unable to retrieve number of cores" )
  f:close()
  num_cores = num_cores or n
  for i=1,num_cores do
    local machine_key = login_host.."_"..i
    if not machines[machine_key] then
      machines[machine_key] = login_host
      table.insert(idle_machines, machine_key)
      num_remote_cores = num_remote_cores + 1
    end
  end
end

----------------------------------------------------------------------------

return ssh
